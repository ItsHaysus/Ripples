<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Glowing Brush + Path Challenge</title>
    <meta name="description" content="Draw glowing trails and fill a path without stopping." />
    <meta name="theme-color" content="#0b1020" />
    <link rel="manifest" href="manifest.json" />
    <style>
      html, body {
        margin: 0; 
        height: 100%; 
        background: #0b1020; 
        touch-action: none;
        display: flex;
        flex-direction: column;
        user-select: none;
        -webkit-user-select: none;
      }
      #controls {
        background: #121722;
        padding: 10px;
        display: flex;
        gap: 10px;
        align-items: center;
        color: white;
        font-family: sans-serif;
        z-index: 10;
      }
      #score {
        font-weight: bold;
        font-size: 1.1rem;
      }
      #canvas-container {
        position: relative;
        flex: 1;
        height: 100%;
      }
      canvas {
        position: absolute;
        top: 0; left: 0;
        width: 100%;
        height: 100%;
        touch-action: none;
        cursor: crosshair;
        user-select: none;
        -webkit-user-select: none;
      }
      select, button {
        background: #1e2735;
        border: none;
        color: white;
        padding: 6px 10px;
        font-size: 1rem;
        border-radius: 4px;
        cursor: pointer;
      }
      select:focus, button:focus {
        outline: 2px solid #4f9eff;
      }
    </style>
  </head>
  <body>
    <div id="controls">
      <label for="colorMode">Brush Color:</label>
      <select id="colorMode">
        <option value="rainbow" selected>Rainbow</option>
        <option value="red">Red</option>
        <option value="black">Black</option>
        <option value="blue">Blue</option>
      </select>
      <button id="resetBtn">Reset</button>
      <div id="score">Score: 0</div>
    </div>
    <div id="canvas-container">
      <canvas id="pathCanvas"></canvas>
      <canvas id="drawCanvas"></canvas>
    </div>
    <script>
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('./service-worker.js')
            .then(() => console.log('Service Worker registered.'))
            .catch(err => console.error('Service Worker registration failed:', err));
        });
      }

      const pathCanvas = document.getElementById('pathCanvas');
      const pathCtx = pathCanvas.getContext('2d', { alpha: false });

      const drawCanvas = document.getElementById('drawCanvas');
      const drawCtx = drawCanvas.getContext('2d', { alpha: true });

      const scoreEl = document.getElementById('score');
      const controls = document.getElementById('controls');

      let width, height, dpr;

      function resize() {
        dpr = window.devicePixelRatio || 1;
        width = window.innerWidth;
        height = window.innerHeight - controls.offsetHeight;

        [pathCanvas, drawCanvas].forEach(canvas => {
          canvas.width = width * dpr;
          canvas.height = height * dpr;
          canvas.style.height = height + 'px';
          canvas.style.width = width + 'px';
        });

        pathCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        drawCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

        pathCtx.lineCap = 'round';
        pathCtx.lineJoin = 'round';
        drawCtx.lineCap = 'round';
        drawCtx.lineJoin = 'round';

        drawPath();
      }

      window.addEventListener('resize', resize);

      // Path variables
      let pathPoints = [];
      const PATH_SEGMENTS = 10;
      const PATH_WIDTH = 40;
      let currentPathIndex = 0;

      // Drawing variables
      let drawing = false;
      let lastX = 0;
      let lastY = 0;
      let hue = 0;
      let colorMode = 'rainbow';

      // Score and state
      let score = 0;
      let lastPointerInsidePath = false;

      // Controls
      const colorSelect = document.getElementById('colorMode');
      const resetBtn = document.getElementById('resetBtn');

      colorSelect.addEventListener('change', (e) => {
        colorMode = e.target.value;
        if (colorMode === 'rainbow') {
          hue = Math.random() * 360;
        }
      });

      resetBtn.addEventListener('click', () => {
        resetGame();
      });

      function generateRandomPath() {
        pathPoints = [];
        const margin = 50;
        let x = margin + Math.random() * (width - 2 * margin);
        let y = margin + Math.random() * (height - 2 * margin);
        pathPoints.push({ x, y });

        for (let i = 1; i < PATH_SEGMENTS; i++) {
          x += (Math.random() - 0.5) * 150;
          y += (Math.random() - 0.5) * 150;
          x = Math.min(Math.max(margin, x), width - margin);
          y = Math.min(Math.max(margin, y), height - margin);
          pathPoints.push({ x, y });
        }
        currentPathIndex = 0;
      }

      function drawPath() {
        pathCtx.clearRect(0, 0, pathCanvas.width, pathCanvas.height);

        pathCtx.save();
        pathCtx.strokeStyle = '#555555';
        pathCtx.lineWidth = PATH_WIDTH;
        pathCtx.lineCap = 'round';
        pathCtx.lineJoin = 'round';
        pathCtx.globalAlpha = 0.2;

        pathCtx.beginPath();
        pathCtx.moveTo(pathPoints[0].x, pathPoints[0].y);
        for (let i = 1; i < pathPoints.length; i++) {
          pathCtx.lineTo(pathPoints[i].x, pathPoints[i].y);
        }
        pathCtx.stroke();
        pathCtx.restore();
      }

      function getBrushColor() {
        switch(colorMode) {
          case 'red': return 'hsl(0, 100%, 65%)';
          case 'black': return 'hsl(0, 0%, 10%)';
          case 'blue': return 'hsl(210, 100%, 65%)';
          case 'rainbow':
          default:
            return `hsl(${hue}, 100%, 65%)`;
        }
      }

      function drawLine(x1, y1, x2, y2) {
        drawCtx.shadowColor = getBrushColor();
        drawCtx.shadowBlur = 15;
        drawCtx.strokeStyle = getBrushColor();
        drawCtx.lineWidth = 15;
        drawCtx.beginPath();
        drawCtx.moveTo(x1, y1);
        drawCtx.lineTo(x2, y2);
        drawCtx.stroke();
        drawCtx.shadowBlur = 0;
      }

      function distanceToSegment(px, py, x1, y1, x2, y2) {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if (len_sq !== 0) param = dot / len_sq;

        let xx, yy;

        if (param < 0) {
          xx = x1;
          yy = y1;
        } else if (param > 1) {
          xx = x2;
          yy = y2;
        } else {
          xx = x1 + param * C;
          yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return Math.sqrt(dx * dx + dy * dy);
      }

      function checkPointerOnPath(x, y) {
        if (currentPathIndex >= pathPoints.length - 1) return false;
        const p1 = pathPoints[currentPathIndex];
        const p2 = pathPoints[currentPathIndex + 1];
        const dist = distanceToSegment(x, y, p1.x, p1.y, p2.x, p2.y);
        return dist <= PATH_WIDTH;
      }

      function advancePathIfNeeded(x, y) {
        if (checkPointerOnPath(x, y)) {
          const p2 = pathPoints[currentPathIndex + 1];
          if (Math.hypot(x - p2.x, y - p2.y) < PATH_WIDTH / 2) {
            currentPathIndex++;
            score++;
            scoreEl.textContent = 'Score: ' + score;
          }
          lastPointerInsidePath = true;
          return true;
        } else {
          if (lastPointerInsidePath) {
            score = 0;
            currentPathIndex = 0;
            scoreEl.textContent = 'Score: ' + score;
          }
          lastPointerInsidePath = false;
          return false;
        }
      }

      function pointerDown(e) {
        drawing = true;
        lastX = e.offsetX;
        lastY = e.offsetY;
        if (colorMode === 'rainbow') {
          hue = Math.random() * 360;
        }
        if (!checkPointerOnPath(lastX, lastY)) {
          score = 0;
          currentPathIndex = 0;
          scoreEl.textContent = 'Score: ' + score;
          lastPointerInsidePath = false;
        } else {
          lastPointerInsidePath = true;
        }
      }

      function pointerMove(e) {
        if (!drawing) return;
        const x = e.offsetX;
        const y = e.offsetY;

        drawLine(lastX, lastY, x, y);
        lastX = x;
        lastY = y;

        if (colorMode === 'rainbow') {
          hue += 2;
          if (hue >= 360) hue -= 360;
        }

        advancePathIfNeeded(x, y);
      }

      function pointerUp() {
        drawing = false;
        lastPointerInsidePath = false;
        score = 0;
        currentPathIndex = 0;
        scoreEl.textContent = 'Score: ' + score;
      }

      const canvasContainer = document.getElementById('canvas-container');

      canvasContainer.addEventListener('pointerdown', e => {
        if (e.target === drawCanvas) pointerDown(e);
      });
      canvasContainer.addEventListener('pointermove', e => {
        if (e.target === drawCanvas) pointerMove(e);
      });
      window.addEventListener('pointerup', pointerUp);
      window.addEventListener('pointercancel', pointerUp);

      function resetGame() {
        drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
        generateRandomPath();
        score = 0;
        currentPathIndex = 0;
        scoreEl.textContent = 'Score: ' + score;
      }

      generateRandomPath();
      resize();
      resetGame();

    </script>
  </body>
</html>
